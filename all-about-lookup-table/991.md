### 解法1: 使用map
&emsp;&emsp;利用map记录下所有数字，然后我们遍历输入数组，对于每一个输入数字a，查看target - a在不在map中。  
&emsp;&emsp;关于在map/set中查找值的注意点：map/set的查找时间复杂度大概是O(n)，每次调用count或者operator[]时，都会进行查找。也许编译器会将它进行优化，但这里不应该过度依赖编译器的行为。可以用find将查找到的迭代器保存下来，后面每次就在该迭代器上进行操作。

### 解法2：使用双指针
&emsp;&emsp;如果不是要返回索引，这道题可能双指针算法是最适合的。首先将输入数组按从小到大进行排序，然后一个指针指向开头，一个指针指向结尾。如果两指针之和大于target，那么尾指针向前推，如果小于target，头指针向后推，否则返回两指针的索引。由于要返回索引，双指针有一定的启动开销，但效率仍然比map的方法要好。

``` c
// 输入：nums = [2,7,11,15] target = 9
// 2 7 11 15  ->  2 + 15 > 9, 尾指针前推
// ^      ^

// 2 7 11 15  ->  2 + 11 > 9, 尾指针前推
// ^   ^

// 2 7 11 15  ->  2 + 7 = 9, bingo
// ^ ^
```