### 解法
&emsp;&emsp;解法上，这道题是十分简单的。对每个字符串中的所有字符进行排序，然后将排序后的字符串放入散列表。这样，所有排序后相等的字符串就属于字母异位词，将他们放到一个vector中就好。

### 关于字符串的哈希
&emsp;&emsp;看过几次类似题型，这种题的一个点就是，如何将字符串不考虑字符顺序，而是按照出现的所有字符进行分类。
+ 一个比较普通的方法就是对字符串中的所有字符进行排序，以排序后的字符串作为key，时间复杂度是O(nlogn)。
+ 对出现的所有字符进行计数，并将计数后的结果转换为一个新的字符，比如"abacacb"就变成"a3b2c2"，时间复杂度是O(n)。但这里有个问题是字母表的规模，26个字母还好，如果是unicode集上，可能就不适用了。
+ 将字母表中的每个字母替换为一个质数，字符串中每出现一个字母就替换为对应的质数，然后将所有质数相乘，时间复杂度是O(n)。这里也有个缺陷，就是字符串足够大后会溢出。  

&emsp;&emsp;第三点成立的证明：反证法。如果有两个拥有不同字母表的字符串a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>和a<sub>1</sub>a<sub>2</sub>b<sub>1</sub>，转换为质数后的乘积相同。即f(a<sub>1</sub>)*f(a<sub>2</sub>)*f(a<sub>3</sub>)=f(a<sub>1</sub>)*f(a<sub>2</sub>)*f(b<sub>1</sub>),那就说明a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>中至少有一个数字有因子b<sub>1</sub>，但他们都是质数，因此只是不可能的。因此a<sub>3</sub>必然等于b<sub>1</sub>。得证。