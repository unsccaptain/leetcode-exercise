### 解法1:散列表
&emsp;&emsp;用map的话很容易做出来。用一个unordered_map来记录每个数字最后一次出现的位置，这样在遍历数组时，每遍历一个数字，比较当前位置和他最后一次出现的位置是否相差在K以内，是就返回，不是则更新最后一次出现的位置。时间复杂度O(n)。  
&emsp;&emsp;(官方的滑动窗口我觉得不是很好，因为数组本身是无序的，导致滑动窗口会退化成一个普通的遍历算法。)